import type { ResponseCookies } from '../../server/web/spec-extension/cookies'

import { requestAsyncStorage } from './request-async-storage.external'
import { actionAsyncStorage } from './action-async-storage.external'
import { RedirectStatusCode } from './redirect-status-code'

const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'

export enum RedirectType {
  push = 'push',
  replace = 'replace',
}

type RedirectErrorDigest =
  `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`

export type RedirectError = Error & {
  digest: RedirectErrorDigest
  mutableCookies: ResponseCookies
}

type RedirectErrorDigestData = {
  url: string
  type: RedirectType
  statusCode: RedirectStatusCode
}

/**
 * Creates a redirect error with the given data. This error should be thrown at
 * the call site of the invoked user function (e.g. `redirect`).
 *
 * @param data the data to create the redirect error with
 * @returns the redirect error
 */
function getRedirectError(data: RedirectErrorDigestData): RedirectError {
  const error = new Error(REDIRECT_ERROR_CODE) as RedirectError
  error.digest = `${REDIRECT_ERROR_CODE};${data.type};${data.url};${data.statusCode};`
  const requestStore = requestAsyncStorage.getStore()
  if (requestStore) {
    error.mutableCookies = requestStore.mutableCookies
  }
  return error
}

/**
 * When used in a streaming context, this will insert a meta tag to
 * redirect the user to the target page. When used in a custom app route, it
 * will serve a 307/303 to the caller.
 *
 * @param url the url to redirect to
 */
export function redirect(
  url: string,
  type: RedirectType = RedirectType.replace
): never {
  const actionStore = actionAsyncStorage.getStore()
  throw getRedirectError({
    url,
    type,
    // If we're in an action, we want to use a 303 redirect
    // as we don't want the POST request to follow the redirect,
    // as it could result in erroneous re-submissions.
    statusCode: actionStore?.isAction
      ? RedirectStatusCode.SeeOther
      : RedirectStatusCode.TemporaryRedirect,
  })
}

/**
 * When used in a streaming context, this will insert a meta tag to
 * redirect the user to the target page. When used in a custom app route, it
 * will serve a 308/303 to the caller.
 *
 * @param url the url to redirect to
 */
export function permanentRedirect(
  url: string,
  type: RedirectType = RedirectType.replace
): never {
  const actionStore = actionAsyncStorage.getStore()
  throw getRedirectError({
    url,
    type,
    // If we're in an action, we want to use a 303 redirect
    // as we don't want the POST request to follow the redirect,
    // as it could result in erroneous re-submissions.
    statusCode: actionStore?.isAction
      ? RedirectStatusCode.SeeOther
      : RedirectStatusCode.PermanentRedirect,
  })
}

/**
 * Checks an error to determine if it's an error generated by the
 * `redirect(url)` helper.
 *
 * @param error the error that may reference a redirect error
 * @returns true if the error is a redirect error
 */
export function isRedirectError(error: unknown): error is RedirectError {
  if (
    typeof error !== 'object' ||
    error === null ||
    !('digest' in error) ||
    typeof error.digest !== 'string'
  ) {
    return false
  }

  const [errorCode, type, destination, status] = error.digest.split(';', 4)

  const statusCode = Number(status)

  return (
    errorCode === REDIRECT_ERROR_CODE &&
    (type === 'replace' || type === 'push') &&
    typeof destination === 'string' &&
    !isNaN(statusCode) &&
    statusCode in RedirectStatusCode
  )
}

/**
 * Parses a redirect error into a more easily digestible object.
 *
 * @param error the error to parse
 * @returns the parsed redirect error
 */
export function parseRedirectError(
  error: RedirectError
): RedirectErrorDigestData {
  const [, type, url, statusCode] = error.digest.split(';', 4)

  return {
    url,
    type: type as RedirectType,
    statusCode: Number(statusCode) as RedirectStatusCode,
  }
}
